var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/types/xrpl.ts
var NETWORKS = {
  LOCALNET: "ws://localhost:6006/",
  TESTNET: "wss://s.altnet.rippletest.net:51233",
  DEVNET: "wss://s.devnet.rippletest.net:51233",
  MAINNET: "wss://s1.ripple.com"
};

// src/types/wallet.ts
import { Client } from "xrpl";
var AbstractWallet = class {
  constructor(network = NETWORKS.TESTNET) {
    __publicField(this, "network");
    this.network = network;
  }
  async getCurrentFee() {
    const client = new Client(this.network);
    await client.connect();
    const feeResponse = await client.request({ command: "fee" });
    const { base_fee: _, median_fee: medianFee, minimum_fee: __, open_ledger_fee: ___ } = feeResponse.result.drops;
    await client.disconnect();
    return {
      medianFee
    };
  }
};

// src/controllers/wallet/xaman.ts
import { Xumm } from "xumm";
var XamanWallet = class extends AbstractWallet {
  constructor(destination) {
    super();
    __publicField(this, "destinationAddress");
    __publicField(this, "connectedAddress");
    __publicField(this, "xumm");
    __publicField(this, "txidTopayloadUuidMapper");
    __publicField(this, "apiKey", "85df3ccf-63cc-402e-b2fa-0ceb8fcf2669");
    __publicField(this, "apiSecret", "07168ac9-1b02-4b62-91c9-028881330f05");
    this.destinationAddress = destination;
    this.apiKey = "85df3ccf-63cc-402e-b2fa-0ceb8fcf2669";
    this.apiSecret = "07168ac9-1b02-4b62-91c9-028881330f05";
    this.xumm = new Xumm(this.apiKey, this.apiSecret);
    this.txidTopayloadUuidMapper = /* @__PURE__ */ new Map();
  }
  async init() {
  }
  async connect() {
    await this.xumm.authorize();
    this.connectedAddress = await this.xumm.user.account;
    return {
      address: this.connectedAddress ?? "",
      providerName: "XAMAN"
    };
  }
  async createPaymentTx({ amount }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const draftTransaction = {
      TransactionType: "Payment",
      Destination: this.destinationAddress,
      Amount: String(amount)
    };
    const payload = await this.xumm.payload?.create({ txjson: draftTransaction });
    if (!payload) throw new Error("Error");
    return payload.uuid;
  }
  async signAndSubmit({ payloadUuid }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    try {
      const isReady = await this.xumm.xapp?.ready();
      if (!isReady) throw new Error();
    } catch (e) {
      return "Can not connect to Xaman Apps";
    }
    await this.xumm.xapp?.openSignRequest({ uuid: payloadUuid });
    return "Sign request opened";
  }
  async getSubmittedTxResult(payloadUuid) {
    const payload = await this.xumm.payload?.get(payloadUuid);
    if (!payload) throw new Error("Error");
    if (payload.response.txid) this.txidTopayloadUuidMapper.set(payload.response.txid, payloadUuid);
    return {
      success: payload.response.dispatched_result === "tesSUCCESS",
      validated: payload.response.dispatched_result === "tesSUCCESS",
      txid: payload.response.txid ?? "",
      raw: payload.response
    };
  }
  async request({ method, params }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const draftTransaction = {
      TransactionType: method,
      ...params
    };
    const payload = await this.xumm.payload?.create({ txjson: draftTransaction });
    if (!payload) throw new Error("Error");
    return payload.uuid;
  }
  async respond(_) {
  }
  async ping() {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const ping = await this.xumm.ping();
    if (ping) return { pong: ping.jwtData?.pong ?? false };
    return { pong: false };
  }
  async disconnect() {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    await this.xumm.logout();
    this.connectedAddress = void 0;
  }
  formatAuthMessage(params) {
    return `Sign in request from ${params.origin}

Payload:
${params.payload}`;
  }
};

// src/controllers/wallet/gem.ts
import { isInstalled, getAddress, sendPayment } from "@gemwallet/api";
import { v4 as uuidv4 } from "uuid";
var GemWallet = class extends AbstractWallet {
  constructor(destination) {
    super();
    __publicField(this, "destinationAddress");
    __publicField(this, "connectedAddress");
    __publicField(this, "txidTopayloadUuidMapper");
    // TODO use store
    __publicField(this, "payloadMapper");
    this.destinationAddress = destination;
    this.txidTopayloadUuidMapper = /* @__PURE__ */ new Map();
    this.payloadMapper = /* @__PURE__ */ new Map();
  }
  async init() {
  }
  async connect() {
    const isGemWalletInstalled = await isInstalled();
    if (!isGemWalletInstalled) {
      throw new Error("Gem Wallet is not installed in your brower");
    }
    const res = await getAddress();
    if (res.type === "response" && res.result) {
      this.connectedAddress = res.result.address;
    } else {
      throw new Error("Can not found wallet address");
    }
    return {
      address: this.connectedAddress,
      providerName: "GEM"
    };
  }
  async createPaymentTx({ amount }) {
    if (!this.connectedAddress) {
      throw new Error("Can not found wallet address");
    }
    const tx = {
      amount: String(amount),
      destination: this.destinationAddress
    };
    const uuid = uuidv4();
    this.payloadMapper.set(uuid, tx);
    return uuid;
  }
  async signAndSubmit({ payloadUuid }) {
    const payload = this.payloadMapper.get(payloadUuid);
    if (!payload) throw new Error("payload not found");
    const sendPaymentResponse = await sendPayment(payload);
    const txid = sendPaymentResponse.result?.hash;
    if (!txid) throw new Error();
    this.txidTopayloadUuidMapper.set(txid, payloadUuid);
    return txid;
  }
  async getSubmittedTxResult(_) {
    return {
      success: true,
      validated: true,
      txid: "dfdfdfd",
      raw: ""
    };
  }
  async request({ method, params }) {
    if (!this.connectedAddress) {
      throw new Error("Can not found wallet address");
    }
    const draftTransaction = {
      TransactionType: method,
      ...params
    };
    const uuid = uuidv4();
    this.payloadMapper.set(uuid, draftTransaction);
    return uuid;
  }
  async respond(_) {
  }
  async ping() {
    const isGemWalletInstalled = await isInstalled();
    if (!isGemWalletInstalled) {
      throw new Error("Gem Wallet is not installed in your brower");
    }
    return { pong: true };
  }
  async disconnect() {
    this.connectedAddress = void 0;
  }
  formatAuthMessage(params) {
    return `Sign in request from ${params.origin}

Payload:
${params.payload}`;
  }
};

// src/index.ts
var XamanWallet2 = XamanWallet;
var GemWallet2 = GemWallet;
export {
  GemWallet2 as GemWallet,
  XamanWallet2 as XamanWallet
};
