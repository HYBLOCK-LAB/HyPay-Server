"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  GemWallet: () => GemWallet2,
  XamanWallet: () => XamanWallet2
});
module.exports = __toCommonJS(index_exports);

// src/types/xrpl.ts
var NETWORKS = {
  LOCALNET: "ws://localhost:6006/",
  TESTNET: "wss://s.altnet.rippletest.net:51233",
  DEVNET: "wss://s.devnet.rippletest.net:51233",
  MAINNET: "wss://s1.ripple.com"
};

// src/types/wallet.ts
var import_xrpl2 = require("xrpl");
var AbstractWallet = class {
  constructor(network = NETWORKS.TESTNET) {
    __publicField(this, "network");
    this.network = network;
  }
  async getCurrentFee() {
    const client = new import_xrpl2.Client(this.network);
    await client.connect();
    const feeResponse = await client.request({ command: "fee" });
    const { base_fee: _, median_fee: medianFee, minimum_fee: __, open_ledger_fee: ___ } = feeResponse.result.drops;
    await client.disconnect();
    return {
      medianFee
    };
  }
};

// src/controllers/wallet/xaman.ts
var import_xumm = require("xumm");
var XamanWallet = class extends AbstractWallet {
  constructor(destination) {
    super();
    __publicField(this, "destinationAddress");
    __publicField(this, "connectedAddress");
    __publicField(this, "xumm");
    __publicField(this, "txidTopayloadUuidMapper");
    __publicField(this, "apiKey", "85df3ccf-63cc-402e-b2fa-0ceb8fcf2669");
    __publicField(this, "apiSecret", "07168ac9-1b02-4b62-91c9-028881330f05");
    this.destinationAddress = destination;
    this.apiKey = "85df3ccf-63cc-402e-b2fa-0ceb8fcf2669";
    this.apiSecret = "07168ac9-1b02-4b62-91c9-028881330f05";
    this.xumm = new import_xumm.Xumm(this.apiKey, this.apiSecret);
    this.txidTopayloadUuidMapper = /* @__PURE__ */ new Map();
  }
  async init() {
  }
  async connect() {
    await this.xumm.authorize();
    this.connectedAddress = await this.xumm.user.account;
    return {
      address: this.connectedAddress ?? "",
      providerName: "XAMAN"
    };
  }
  async createPaymentTx({ amount }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const draftTransaction = {
      TransactionType: "Payment",
      Destination: this.destinationAddress,
      Amount: String(amount)
    };
    const payload = await this.xumm.payload?.create({ txjson: draftTransaction });
    if (!payload) throw new Error("Error");
    return payload.uuid;
  }
  async signAndSubmit({ payloadUuid }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    try {
      const isReady = await this.xumm.xapp?.ready();
      if (!isReady) throw new Error();
    } catch (e) {
      return "Can not connect to Xaman Apps";
    }
    await this.xumm.xapp?.openSignRequest({ uuid: payloadUuid });
    return "Sign request opened";
  }
  async getSubmittedTxResult(payloadUuid) {
    const payload = await this.xumm.payload?.get(payloadUuid);
    if (!payload) throw new Error("Error");
    if (payload.response.txid) this.txidTopayloadUuidMapper.set(payload.response.txid, payloadUuid);
    return {
      success: payload.response.dispatched_result === "tesSUCCESS",
      validated: payload.response.dispatched_result === "tesSUCCESS",
      txid: payload.response.txid ?? "",
      raw: payload.response
    };
  }
  async request({ method, params }) {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const draftTransaction = {
      TransactionType: method,
      ...params
    };
    const payload = await this.xumm.payload?.create({ txjson: draftTransaction });
    if (!payload) throw new Error("Error");
    return payload.uuid;
  }
  async respond(_) {
  }
  async ping() {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    const ping = await this.xumm.ping();
    if (ping) return { pong: ping.jwtData?.pong ?? false };
    return { pong: false };
  }
  async disconnect() {
    if (!this.xumm) {
      throw new Error("Xaman Wallet SDK is not available.");
    }
    await this.xumm.logout();
    this.connectedAddress = void 0;
  }
  formatAuthMessage(params) {
    return `Sign in request from ${params.origin}

Payload:
${params.payload}`;
  }
};

// src/controllers/wallet/gem.ts
var import_api = require("@gemwallet/api");
var import_uuid = require("uuid");
var GemWallet = class extends AbstractWallet {
  constructor(destination) {
    super();
    __publicField(this, "destinationAddress");
    __publicField(this, "connectedAddress");
    __publicField(this, "txidTopayloadUuidMapper");
    // TODO use store
    __publicField(this, "payloadMapper");
    this.destinationAddress = destination;
    this.txidTopayloadUuidMapper = /* @__PURE__ */ new Map();
    this.payloadMapper = /* @__PURE__ */ new Map();
  }
  async init() {
  }
  async connect() {
    const isGemWalletInstalled = await (0, import_api.isInstalled)();
    if (!isGemWalletInstalled) {
      throw new Error("Gem Wallet is not installed in your brower");
    }
    const res = await (0, import_api.getAddress)();
    if (res.type === "response" && res.result) {
      this.connectedAddress = res.result.address;
    } else {
      throw new Error("Can not found wallet address");
    }
    return {
      address: this.connectedAddress,
      providerName: "GEM"
    };
  }
  async createPaymentTx({ amount }) {
    if (!this.connectedAddress) {
      throw new Error("Can not found wallet address");
    }
    const tx = {
      amount: String(amount),
      destination: this.destinationAddress
    };
    const uuid = (0, import_uuid.v4)();
    this.payloadMapper.set(uuid, tx);
    return uuid;
  }
  async signAndSubmit({ payloadUuid }) {
    const payload = this.payloadMapper.get(payloadUuid);
    if (!payload) throw new Error("payload not found");
    const sendPaymentResponse = await (0, import_api.sendPayment)(payload);
    const txid = sendPaymentResponse.result?.hash;
    if (!txid) throw new Error();
    this.txidTopayloadUuidMapper.set(txid, payloadUuid);
    return txid;
  }
  async getSubmittedTxResult(_) {
    return {
      success: true,
      validated: true,
      txid: "dfdfdfd",
      raw: ""
    };
  }
  async request({ method, params }) {
    if (!this.connectedAddress) {
      throw new Error("Can not found wallet address");
    }
    const draftTransaction = {
      TransactionType: method,
      ...params
    };
    const uuid = (0, import_uuid.v4)();
    this.payloadMapper.set(uuid, draftTransaction);
    return uuid;
  }
  async respond(_) {
  }
  async ping() {
    const isGemWalletInstalled = await (0, import_api.isInstalled)();
    if (!isGemWalletInstalled) {
      throw new Error("Gem Wallet is not installed in your brower");
    }
    return { pong: true };
  }
  async disconnect() {
    this.connectedAddress = void 0;
  }
  formatAuthMessage(params) {
    return `Sign in request from ${params.origin}

Payload:
${params.payload}`;
  }
};

// src/index.ts
var XamanWallet2 = XamanWallet;
var GemWallet2 = GemWallet;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GemWallet,
  XamanWallet
});
